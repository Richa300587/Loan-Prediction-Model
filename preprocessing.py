# -*- coding: utf-8 -*-
"""Loanapplicationdatapreprocessing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ALCVa68-BvLiqBQLli0zSHrMn1wsjTKM
"""
from sklearn.base import BaseEstimator,TransformerMixin
from google.colab import drive
import sys
drive.mount('/content/drive')
sys.path.append('/content/drive/MyDrive/Loanmodel_custom_modules')
import confi as confi
#No extracting path having all saved artifacts and my test data for prediction that i will use in my custom estimators to make pipeline
p=confi.artifact_path

import importlib
import subprocess

# Read the list of packages from the file
with open('/content/drive/MyDrive/Loanmodel_custom_modules/Loanrequirement.txt', 'r') as f:
    packages = [line.strip() for line in f.readlines()]

# Import each package, installing it via pip if necessary
for package in packages:
    try:
        importlib.import_module(package)
        print(package)
    except ImportError:
        print(f"{package} is not installed. Installing...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])

import numpy as np
import pandas as pd
import pickle
import sys
from pathlib import Path
import os
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import chi2_contingency
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import MinMaxScaler
pd.set_option('display.max_columns', 1500)
# set seed for reproducibility
np.random.seed(123)


import warnings
warnings.filterwarnings('ignore')

#Extend cell width
from IPython.core.display import display, HTML
display(HTML("<style>.container { width:80% !important; }</style>"))
from category_encoders import TargetEncoder
from sklearn.pipeline import Pipeline




class money_data(BaseEstimator,TransformerMixin):
  def __init__(self,variables=None):
    self.variables=variables
  def fit(self,X,y=None):
    self.replace_values={'\$':'',',':''}
    return self
  def transform(self,X,y=None):
    X=X.copy()
    X[self.variables]=X[self.variables].replace(self.replace_values,regex=True).astype(float)
    print('success')
    return X

class Numerical_train_imputer(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
#  def fit(self,X,y=None): if i want to impute with zero
#  return self
#  def transform(self,X):
#    X[self.variables]=X[self.variables].fillna(value=self.imputer)
#    return X
  def fit(self,X,y=None):     # if i want to replace the missing values with mean of that column then my code would have been
    for feature in self.variables:
     self.imputer=X[feature].mean()
     pickle.dump(self.imputer,open(self.path+feature+'_imputer.pkl','wb'))
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for feature in self.variables:
      enc=pickle.load(open(self.path+feature+'_imputer.pkl','rb'))
      X[feature]=X[feature].fillna(value=enc)
    print('success')
    return X

class categorical_train_imputer(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    for feature in self.variables:
     self.imputer='Missing'
     pickle.dump(self.imputer,open(self.path+feature+'_imputer.pkl','wb'))
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for feature in self.variables:
      enc=pickle.load(open(self.path+feature+'_imputer.pkl','rb'))
      X[feature]=X[feature].fillna(value=enc)
    print('success')
    return X

class drop_colunms(BaseEstimator,TransformerMixin):
  def __init__(self,variables=None):
    self.variables=variables
  def fit(self,X,y=None):
    return self
  def transform(self,X,y=None):
    X=X.copy()
    X=X.drop(columns=self.variables,axis=1)
    print('success')
    return X

class onehot_train_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,enc=None,variables=None):
    self.enc=enc
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    for col in self.variables:
      e=self.enc.fit(X[[col]])
      pickle.dump(e,open(self.path+col+'_enc.pkl','wb'))
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_enc.pkl','rb'))
      result=enc.transform(X[[col]])
      ohe_columns = [col+"_"+str(x) for x in enc.categories_[0]]
      result_train = pd.DataFrame(result, columns=ohe_columns , index=X.index)
      X = pd.concat([X, result_train.reindex(X.index)], axis=1 , join='inner')
    X.drop(columns=self.variables,inplace=True)
    print('success')
    return X

class target_train_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,enc=None,variables=None):
    self.enc=enc
    self.path=path
    self.variables=variables
  def fit(self,X,y=None):
    for col in self.variables:
      e=self.enc.fit(X[[col]],y)
      pickle.dump(e,open(self.path+col+'_trg.pkl','wb'))
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_trg.pkl','rb'))
      result=enc.transform(X[[col]])
      new_col_name = col+"_trg"
      X[new_col_name] = enc.transform(X[[col]])
    X.drop(columns=self.variables,inplace=True)
    print('success')
    return X

class onehot_test_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_enc.pkl','rb'))
      result=enc.transform(X[[col]])
      ohe_columns = [col+"_"+str(x) for x in enc.categories_[0]]
      result_train = pd.DataFrame(result, columns=ohe_columns , index=X.index)
      X = pd.concat([X, result_train.reindex(X.index)], axis=1 , join='inner')
    X.drop(columns=self.variables,inplace=True)
    return X

class target_test_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_trg.pkl','rb'))
      result=enc.transform(X[[col]])
      new_col_name = col+"_trg"
      X[new_col_name] = enc.transform(X[[col]])
    X.drop(columns=self.variables,inplace=True)
    return X

class scalar_train_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,scale=None,variables=None):
    self.scale=scale
    self.path=path
    self.variables=variables
  def fit(self,X,y=None):
    for col in self.variables:
      e=self.scale.fit(X[[col]])
      pickle.dump(e,open(self.path+col+'_scale.pkl','wb'))
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_scale.pkl','rb'))
      result=enc.transform(X[[col]])
      new_col_name = col+"_scale"
      X[new_col_name] = enc.transform(X[[col]])
    X.drop(columns=self.variables,inplace=True)
    print('success')
    return X

class scalar_test_encoder(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for col in self.variables:
      enc=pickle.load(open(self.path+col+'_scale.pkl','rb'))
      result=enc.transform(X[[col]])
      new_col_name = col+"_scale"
      X[new_col_name] = enc.transform(X[[col]])
    X.drop(columns=self.variables,inplace=True)
    return X

class Numerical_test_imputer(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
#  def fit(self,X,y=None): if i want to impute with zero
#  return self
#  def transform(self,X):
#    X[self.variables]=X[self.variables].fillna(value=self.imputer)
#    return X
  def fit(self,X,y=None):     # if i want to replace the missing values with mean of that column then my code would have been
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for feature in self.variables:
      enc=pickle.load(open(self.path+feature+'_imputer.pkl','rb'))
      X[feature]=X[feature].fillna(value=enc)
    return X

class categorical_test_imputer(BaseEstimator,TransformerMixin):
  def __init__(self,path=None,variables=None):
    self.variables=variables
    self.path=path
  def fit(self,X,y=None):
    return self
  def transform(self,X,y=None):
    X=X.copy()
    for feature in self.variables:
      enc=pickle.load(open(self.path+feature+'_imputer.pkl','rb'))
      X[feature]=X[feature].fillna(value=enc)
    return X

class discrete_columns_matrix(BaseEstimator,TransformerMixin):
  def __init__(self,variables=None):
    self.variables=variables
  def fit(self,X,y=None):
    self.pval_mat=[]
    self.method=chi2_contingency
    for v in self.variables:
      m=[]
      for va in self.variables:
        contingency_table = pd.crosstab(X[v], X[va])
        chi2, p_value, dof, expected = self.method(contingency_table)
        m.append(p_value)
      self.pval_mat.append(m)
    df = pd.DataFrame(self.pval_mat, index=self.variables, columns=self.variables)
    print('success')
    return df